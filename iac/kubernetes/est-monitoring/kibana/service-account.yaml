---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: pre-install-elasticsearch-kibana
  namespace: est-monitoring
  labels:
    app: kibana
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: pre-install-elasticsearch-kibana
  namespace: est-monitoring
  labels:
    app: kibana
rules:
  - apiGroups:
      - ""
    resources:
      - secrets
    verbs:
      - create
      - update
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: pre-install-elasticsearch-kibana
  namespace: est-monitoring
  labels:
    app: kibana
subjects:
  - kind: ServiceAccount
    name: pre-install-elasticsearch-kibana
    namespace: est-monitoring
roleRef:
  kind: Role
  name: pre-install-elasticsearch-kibana
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: batch/v1
kind: Job
metadata:
  name: pre-install-elasticsearch-kibana
  namespace: est-monitoring
  labels:
    app: kibana
spec:
  backoffLimit: 20
  template:
    spec:
      restartPolicy: Never
      containers:
        - name: create-kibana-token
          image: "dockerhub.timeweb.cloud/kibana:8.14.3"
          imagePullPolicy: "IfNotPresent"
          command: ["/usr/share/kibana/node/bin/node"]
          args:
            - /usr/share/kibana/install-scripts/manage-es-token.js
            - create
          env:
            - name: "ELASTICSEARCH_USERNAME"
              valueFrom:
                secretKeyRef:
                  name: elasticsearch-credentials
                  key: username
            - name: "ELASTICSEARCH_PASSWORD"
              valueFrom:
                secretKeyRef:
                  name: elasticsearch-credentials
                  key: password
            - name: ELASTICSEARCH_SSL_CERTIFICATEAUTHORITIES
              value: "/usr/share/kibana/config/certs/elastic.crt"
          volumeMounts:
            - name: elasticsearch-certs
              mountPath: /usr/share/kibana/config/certs
              readOnly: true
            - name: elasticsearch-kibana-install-scripts
              mountPath: /usr/share/kibana/install-scripts

      serviceAccount: pre-install-elasticsearch-kibana

      volumes:
        - name: elasticsearch-certs
          secret:
            secretName: elasticsearch-certs
        - name: elasticsearch-kibana-install-scripts
          configMap:
            name: elasticsearch-kibana-install-scripts
            defaultMode: 0755
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: elasticsearch-kibana-install-scripts
  namespace: est-monitoring
  labels:
    app: kibana
data:
  ### Спасибо helm чарту за этот скрипт
  manage-es-token.js: |
    const https = require('https');
    const fs = require('fs');

    // Read environment variables
    function getEnvVar(name) {
        if (!process.env[name]) {
            throw new Error(name + ' environment variable is missing')
        }
        return process.env[name]
    }

    // Elasticsearch API
    const esPath = '_security/service/elastic/kibana/credential/token/elasticsearch-kibana';
    const esUrl = 'https://elasticsearch:9200' + '/' + esPath
    const esUsername = getEnvVar('ELASTICSEARCH_USERNAME');
    const esPassword = getEnvVar('ELASTICSEARCH_PASSWORD');
    const esAuth = esUsername + ':' + esPassword;
    const esCaFile = getEnvVar('ELASTICSEARCH_SSL_CERTIFICATEAUTHORITIES');
    const esCa = fs.readFileSync(esCaFile);

    // Kubernetes API
    const k8sHostname = getEnvVar('KUBERNETES_SERVICE_HOST');
    const k8sPort = getEnvVar('KUBERNETES_SERVICE_PORT_HTTPS');
    const k8sPostSecretPath = 'api/v1/namespaces/est-monitoring/secrets';
    const k8sDeleteSecretPath = 'api/v1/namespaces/est-monitoring/secrets/elasticsearch-kibana-es-token';
    const k8sPostSecretUrl = `https://${k8sHostname}:${k8sPort}/${k8sPostSecretPath}`;
    const k8sDeleteSecretUrl = `https://${k8sHostname}:${k8sPort}/${k8sDeleteSecretPath}`;
    const k8sBearer = fs.readFileSync('/run/secrets/kubernetes.io/serviceaccount/token');
    const k8sCa = fs.readFileSync('/run/secrets/kubernetes.io/serviceaccount/ca.crt');

    // Post Data
    const esTokenDeleteOptions = {
        method: 'DELETE',
        auth: esAuth,
        ca: esCa,
    };
    const esTokenCreateOptions = {
        method: 'POST',
        auth: esAuth,
        ca: esCa,
    };
    const secretCreateOptions = {
        method: 'POST',
        ca: k8sCa,
        headers: {
            'Authorization': 'Bearer ' + k8sBearer,
            'Accept': 'application/json',
            'Content-Type': 'application/json',
        }
    };
    const secretDeleteOptions = {
        method: 'DELETE',
        ca: k8sCa,
        headers: {
            'Authorization': 'Bearer ' + k8sBearer,
            'Accept': 'application/json',
            'Content-Type': 'application/json',
        }
    };

    function requestPromise(url, httpsOptions, extraOptions = {}) {
        return new Promise((resolve, reject) => {
            const request = https.request(url, httpsOptions, response => {
                
                console.log('statusCode:', response.statusCode);
                
                let isSuccess = undefined;
                
                if (typeof(extraOptions.extraStatusCode) != "undefined" && extraOptions.extraStatusCode != null) {
                    isSuccess = response.statusCode >= 200 && response.statusCode < 300 || response.statusCode == extraOptions.extraStatusCode;
                } else {
                    isSuccess = response.statusCode >= 200 && response.statusCode < 300;
                }
                
                let data = '';
                response.on('data', chunk => data += chunk); // accumulate data
                response.once('end', () => isSuccess ? resolve(data) : reject(data));  // resolve promise here
            });
            
            request.once('error', err => {
                // This won't log anything for e.g. an HTTP 404 or 500 response,
                // since from HTTP's point-of-view we successfully received a
                // response.
                console.log(`${httpsOptions.method} ${httpsOptions.path} failed: `, err.message || err);
                reject(err);  // if promise is not already resolved, then we can reject it here
            });
            
            if (typeof(extraOptions.payload) != "undefined") {
                request.write(extraOptions.payload);
            }
            request.end();
        });
    }

    function createEsToken() {
        // Chaining requests
        console.log('Cleaning previous token');
        // 404 status code is accepted if there is no previous token to clean
        return requestPromise(esUrl, esTokenDeleteOptions, {extraStatusCode: 404}).then(() => {
            console.log('Creating new token');
            return requestPromise(esUrl, esTokenCreateOptions).then(response => {
                const body = JSON.parse(response);
                const token = body.token.value
                
                // Encode the token in base64
                const base64Token = Buffer.from(token, 'utf8').toString('base64');
                
                // Prepare the k8s secret
                const secretData = JSON.stringify({
                    "apiVersion": "v1",
                    "kind": "Secret",
                    "metadata": {
                        "namespace": "est-monitoring",
                        "name": "elasticsearch-kibana-es-token",
                    },
                    "type": "Opaque",
                    "data": {
                        "token": base64Token,
                    }
                })
                
                // Create the k8s secret
                console.log('Creating K8S secret');
                return requestPromise(k8sPostSecretUrl, secretCreateOptions, {payload: secretData})
            });
        });
    }

    function cleanEsToken() {
        // Chaining requests
        console.log('Cleaning token');
        return requestPromise(esUrl, esTokenDeleteOptions).then(() => {
            // Create the k8s secret
            console.log('Delete K8S secret');
            return requestPromise(k8sDeleteSecretUrl, secretDeleteOptions)
        });
    }

    const command = process.argv[2];
    switch (command) {
        case 'create':
            console.log('Creating a new Elasticsearch token for Kibana')
            createEsToken().catch(err => {
                console.error(err);
                process.exit(1);
            });
            break;
        case 'clean':
            console.log('Cleaning the Kibana Elasticsearch token')
            cleanEsToken().catch(err => {
                console.error(err);
                process.exit(1);
            });
            break;
        default:
            console.log('Unknown command');
            process.exit(1);
    }